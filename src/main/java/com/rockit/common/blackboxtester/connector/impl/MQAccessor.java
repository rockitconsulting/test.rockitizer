package com.rockit.common.blackboxtester.connector.impl;import static io.github.rockitconsulting.test.rockitizer.configuration.Configuration.configuration;import io.github.rockitconsulting.test.rockitizer.configuration.model.res.connectors.MQConnectorCfg;import io.github.rockitconsulting.test.rockitizer.configuration.model.res.datasources.MQDataSource;import io.github.rockitconsulting.test.rockitizer.payload.model.MqPayload;import java.io.IOException;import java.util.HashMap;import java.util.Hashtable;import java.util.Map;import org.apache.log4j.Logger;import com.google.common.base.Strings;import com.ibm.mq.MQException;import com.ibm.mq.MQGetMessageOptions;import com.ibm.mq.MQMessage;import com.ibm.mq.MQPutMessageOptions;import com.ibm.mq.MQQueue;import com.ibm.mq.MQQueueManager;import com.ibm.mq.constants.CMQC;import com.ibm.mq.constants.MQConstants;import com.ibm.mq.headers.MQDataException;import com.ibm.msg.client.wmq.compat.base.internal.MQC;import com.rockit.common.blackboxtester.exceptions.ConnectorException;/** * Test.Rockitizer - API regression testing framework Copyright (C) 2020 * rockit.consulting GmbH * * This program is free software: you can redistribute it and/or modify it under * the terms of the GNU General Public License as published by the Free Software * Foundation, either version 3 of the License, or (at your option) any later * version. * * This program is distributed in the hope that it will be useful, but WITHOUT * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more * details. * * You should have received a copy of the GNU General Public License along with * this program. If not, see http://www.gnu.org/licenses/. * */public abstract class MQAccessor {	public static final Logger LOGGER = Logger.getLogger(MQAccessor.class.getName());	static Map<String, MQQueueManager> cache = new HashMap<>();	protected String qManager;	protected String qName;	protected byte[] message;	protected String messageId;	protected String channelname;	protected int port;	protected String hostname;	private final QueueOption qOption;	private HashMap<String, Object> mqEnv;	private MQConnectorCfg conCfg;	public MQAccessor(String id) {		conCfg = (MQConnectorCfg) configuration().getConnectorById(id);		MQDataSource ds = configuration().getMQDataSourceByConnector(conCfg);		mqEnv = new HashMap<String, Object>();		mqEnv.put(MQConstants.USE_MQCSP_AUTHENTICATION_PROPERTY, false);		mqEnv.put(CMQC.CHANNEL_PROPERTY, ds.getChannel());		mqEnv.put(CMQC.HOST_NAME_PROPERTY, ds.getHost());		mqEnv.put(CMQC.PORT_PROPERTY, new Integer(ds.getPort())); // the																	// CASE-SENSITIVE		if (!Strings.isNullOrEmpty(ds.getUser()) && !Strings.isNullOrEmpty(ds.getPassword())) {			mqEnv.put(MQConstants.USE_MQCSP_AUTHENTICATION_PROPERTY, true);			mqEnv.put(CMQC.USER_ID_PROPERTY, ds.getUser());			mqEnv.put(CMQC.PASSWORD_PROPERTY, ds.getPassword());		}		this.port = Integer.valueOf(ds.getPort());		this.hostname = ds.getHost();		this.channelname = ds.getChannel();		this.qManager = ds.getQmgr();		this.qName = conCfg.getQueue();		this.qOption = QueueOption.GenerateMsgId;	}	public String get() {		try {												final MQMessage msg = new MQMessage();			final MQGetMessageOptions gmo = new MQGetMessageOptions();			gmo.options = CMQC.MQGMO_PROPERTIES_FORCE_MQRFH2; // CMQC.MQGMO_PROPERTIES_IN_HANDLE									final MQQueue queue = getQueue();						if (queue.getCurrentDepth() < 1) {				return null;			}			queue.get(msg, gmo);			MqPayload payload = MQPayloadBuilder.newPayload(msg);			if (queue.isOpen()) {				queue.close();			}			return MQPayloadBuilder.toXmlString(payload);		} catch (MQException | IOException | MQDataException e) {			throw new ConnectorException("Can not read queue: " + qName, e);		}	}	private MQQueue getQueue() throws MQException {		final int openOptions = CMQC.MQOO_INQUIRE + CMQC.MQOO_FAIL_IF_QUIESCING + CMQC.MQOO_INPUT_SHARED + CMQC.MQGMO_PROPERTIES_AS_Q_DEF;		MQQueue queue = getQmgr().accessQueue(qName, openOptions);				if(queue.getQueueType() == MQC.MQQT_ALIAS) {			    int[] selectors = new int[1];			    int[] intAttrs = new int[1];			    byte[] charAttrs = new byte[64];			    selectors[0] = CMQC.MQCA_BASE_OBJECT_NAME;			    queue.inquire(selectors, intAttrs, charAttrs);					    String baseQ = new String(charAttrs).trim();			    			    if(queue.isOpen()) {			    	queue.close();			    }			    queue = getQmgr().accessQueue(baseQ, openOptions); 		}		return queue;	}	private void write(final MQQueue queue, final String name, final byte[] message) {		try {			MQMessage mQMsg = MQPayloadBuilder.newMqMessageFromXMLString(message);			final MQPutMessageOptions pmo = new MQPutMessageOptions();			switch (qOption) {			case SetMsgId:				pmo.options |= CMQC.MQPMO_SET_ALL_CONTEXT;// Broker, MsgId wird															// gesetzt				break;			case SetMsgIdAndUserId:				pmo.options |= CMQC.MQPMO_SET_IDENTITY_CONTEXT;// Vitria, MsgId																// und UserId																// wird gesetzt				mQMsg.userId = "unknown";			default:			}			queue.put(mQMsg, pmo);			LOGGER.debug("Message successfully written to " + queue.getName());		} catch (IOException | MQException ex) {			throw new ConnectorException("queue not be written: " + qName, ex);		}	}	public void putMessage(final byte[] message, final String name) {		try {			final MQQueueManager qMgr = getQmgr();			int openOptions = CMQC.MQOO_OUTPUT;// Standard, MsgId wird generiert			switch (this.qOption) {			case SetMsgId:				openOptions = CMQC.MQOO_OUTPUT | CMQC.MQOO_SET_ALL_CONTEXT;// Broker,																			// MsgId																			// wird																			// gesetzt				break;			case SetMsgIdAndUserId:				openOptions = CMQC.MQOO_OUTPUT | CMQC.MQOO_SET_IDENTITY_CONTEXT;// Vitria,																				// MsgId																				// und																				// UserId																				// wird																				// gesetzt				break;			default:			}			final MQQueue queue = qMgr.accessQueue(qName, openOptions);			write(queue, name, message);// Writing message into the queue			queue.close();		} catch (final MQException ex) {			throw new ConnectorException("can not write queue: " + qName, ex);		}	}	private MQQueueManager getQmgr() {		if (null == cache.get(qManager)) {			LOGGER.debug("Connecting MQQueueManager " + qManager);			try {				cache.put(qManager, new MQQueueManager(qManager, new Hashtable<String, Object>(mqEnv)));			} catch (final MQException e) {				throw new ConnectorException("MQQueueManager not available: " + qManager, e);			}		}		return cache.get(qManager);	}	private enum QueueOption {		GenerateMsgId("GenerateMsgId"), SetMsgId("SetMsgId"), SetMsgIdAndUserId("SetMsgIdAndUserId");		private QueueOption(final String opt) {		}	}	public String getQName() {		return qName;	}	public String getMessageId() {		return messageId;	}	public void setMessageId(final String messageId) {		this.messageId = messageId;	}	@Override	public String toString() {		return "WebsphereMQ(qManager=" + this.qManager + ", qName=" + this.qName + ", hostname=" + this.hostname + ", port=" + this.port + ", channelname="				+ this.channelname + ")";	}	public abstract String getId();	public abstract String getType();	/*	 * private void closeQueueMgr(MQQueueManager qMgr) throws MQException {	 * System.out.println("Disconnecting from the Queue Manager");	 * qMgr.disconnect(); }	 */	// private void setQueueOption(String opt) {	// QueueOption option = QueueOption.getOption(opt);	// if (option != null) {	// this.qOption = option;	// }	// }	//	// private void setApplicationIdData(String applicationIdData) {	// this.applicationIdData = applicationIdData;	// }	public HashMap<String, Object> getMqEnv() {		return mqEnv;	}}